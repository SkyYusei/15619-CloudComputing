package com.cloudcomputing.samza.pitt_cabs;

import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Queue;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.io.IOException;
import java.util.HashMap;

import org.apache.samza.config.Config;
import org.apache.samza.storage.kv.Entry;
import org.apache.samza.storage.kv.KeyValueIterator;
import org.apache.samza.storage.kv.KeyValueStore;
import org.apache.samza.system.IncomingMessageEnvelope;
import org.apache.samza.system.OutgoingMessageEnvelope;
import org.apache.samza.task.InitableTask;
import org.apache.samza.task.MessageCollector;
import org.apache.samza.task.StreamTask;
import org.apache.samza.task.TaskContext;
import org.apache.samza.task.TaskCoordinator;
import org.apache.samza.task.WindowableTask;

import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.SerializationConfig;
import kafka.utils.Json;

/**
 * Consumes the stream of driver location updates and rider cab requests.
 * Outputs a stream which joins these 2 streams and gives a stream of rider
 * to driver matches.
 */
public class DriverMatchTask implements StreamTask, InitableTask, WindowableTask {

  /* Define per task state here. (kv stores etc) */
	private KeyValueStore<String, Map<String,Object>> driverloc;
	private KeyValueStore<String, String> blockavailable;
	
  @Override
  @SuppressWarnings("unchecked")
  public void init(Config config, TaskContext context) throws Exception {
	driverloc = (KeyValueStore<String, Map<String,Object>>) context.getStore("driver-loc");
	blockavailable = (KeyValueStore<String, String>) context.getStore("block-availabe");
  }

  @Override
  @SuppressWarnings("unchecked")
  public void process(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator) {
	  String incomingStream = envelope.getSystemStreamPartition().getStream();
	  if(incomingStream.equals(DriverMatchConfig.DRIVER_LOC_STREAM.getStream())){
		 //process location log
		  processdriverlocations((Map<String, Object>) envelope.getMessage(), collector);
	  }else if(incomingStream.equals(DriverMatchConfig.EVENT_STREAM.getStream())){
		  //process event
		  processevent((Map<String, Object>)envelope.getMessage(), collector);
	  }else{
	      throw new IllegalStateException("Unexpected input stream: " + envelope.getSystemStreamPartition());
	  }
  }
  public void processdriverlocations(Map<String, Object> message, MessageCollector collector) {
	if(!message.get("type").equals("DRIVER_LOCATION")){
	      throw new IllegalStateException("Unexpected event type on follows stream: " + message.get("event"));
	}
	String driverId = (int) message.get("driverId")+"";
	String latitude =(int) message.get("latitude")+"";
	String longitude = (int) message.get("longitude")+"";
	String block = (int)message.get("blockId")+"";
	Map<String, Object> dlocinfo = driverloc.get(block);
	if(dlocinfo != null){
		dlocinfo.put(driverId, latitude+":"+longitude);
	}else{
		Map<String, Object> map = new HashMap<>();
		map.put(driverId,latitude+":"+longitude);
		driverloc.put(block, map);
	}
	
  }
  
  public void processevent(Map<String, Object> message, MessageCollector collector) { 
	  if(message.get("type").equals("LEAVING_BLOCK")||message.get("type").equals("ENTERING_BLOCK")){
		  String driverId = (int) message.get("driverId")+"";
		  String latitude =(int) message.get("latitude")+"";
		  String longitude = (int) message.get("longitude")+"";
		  String block = (int)message.get("blockId")+"";
		  if(message.get("status").equals("AVAILABLE")){
			  Map<String, Object> dlocinfo = driverloc.get(block);
			  if(dlocinfo != null){
					dlocinfo.put(driverId, latitude+":"+longitude);
				}else{
					Map<String, Object> map = new Map<String, Object>();
					map.put(driverId,latitude+":"+longitude);
					driverloc.put(block, map);
				}
		  }else{
		//if not just delete it
			  Map<String, Object> map = driverloc.get(block);
			  if(map != null){
				  map.remove(driverId);
			  }
			  
		  }		
	  }else if(message.get("type").equals("RIDE_COMPLETE")){
		  String driverId = (int) message.get("driverId")+"";
		  String latitude =(int) message.get("latitude")+"";
		  String longitude = (int) message.get("longitude")+"";
		  String block = (int)message.get("blockId")+"";
		  Map<String, Object> map = driverloc.get(block);
		  if(map != null){
			  map.put(driverId, latitude+":"+longitude);
		  }else{
				Map<String, Object> map1 = new HashMap<>();
				map1.put(driverId,latitude+":"+longitude);
				driverloc.put(block, map1);
		 }
		 
	  }else if(message.get("type").equals("RIDE_REQUEST")){
		  String riderId = (int) message.get("riderId")+"";
		  int rlatitude =(int) message.get("latitude");
		  int rlongitude = (int) message.get("longitude"); 
		  String rblock = (int)message.get("blockId")+"";
		  Map<String,Object> map = driverloc.get(rblock);
		  double spf = 1.0;
		  String matchD ="";
		  int distance =Integer.MAX_VALUE;
		  
		  if(map!=null){
			  String available = map.size()+"";  
			  String former = blockavailable.get(rblock);
			  blockavailable.put(rblock, available+":"+former);
			  String[] b = former.split(":");
			  if((b.length-1) <5){
				  spf = 1.0;
			  }else{
				  int sum = 0;
				  double A=0;
				  for(int i = 0;i<5;i++){
					  sum += Integer.parseInt(b[i]);
					  A = sum/Integer.parseInt(available);
				  }
				  if(A>=1.8){
					  spf =1.0;
				  }else{
					  double sf =  (8 *(1.8 - A)/(1.8 - 1));
					  spf = sf+1;
				  } 
			  }
			  for(Map.Entry<String, Object> entry : map.entrySet()){
				  String did = entry.getKey();
				  String[] loc =((String)entry.getValue()).split(":");
				  
				  int d = ((int)Math.pow((Integer.parseInt(loc[0])-rlatitude)
						  , 2)+(int)Math.pow((Integer.parseInt(loc[1])-rlongitude), 2));
				  if(d < distance){
					  distance =d;
					  matchD = did;
				  }
			  }
			  HashMap<String, Object> out = new HashMap<>();
			  out.put("riderId", Integer.parseInt(riderId));
			  out.put("driverId", Integer.parseInt(matchD));
			  out.put("priceFactor", spf);
			  collector.send(new OutgoingMessageEnvelope(DriverMatchConfig.MATCH_STREAM,null,null,out));
		  }
		  
	  }
}

  
  
  
  @Override
  public void window(MessageCollector collector, TaskCoordinator coordinator) {
	//this function is called at regular intervals, not required for this project
  }
}
